<HTML>
<HEAD>
<TITLE>MVPoly - Language Commands</TITLE>
<LINK REV="made" HREF="mailto:bguarrac@hotmail.com">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#EXAMPLES">EXAMPLES </A>
	<LI><A HREF="#REFERENCES">REFERENCES</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
MVPoly - Language Commands

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
MVPoly is an implementation of a simple mult-variate symbolic math package
oriented towards polynomial and monomial operations.

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
Provided with the MVPoly library is a simple interpreter interfacing to the
library. Although the language is simple, it still provides a great deal of
functionality. The commands available are as follows:

<P>
Next to each variable sensitive command is the symbol [X], where X is the
number of variables the command is valid for. For single variable commands,
X=1, and for an arbitrary number of variablees, X=N.

<P>
Two commands, monOrder and varOrder MUST always preceed any polynomial
declarations or operations simply because the define the 'environment' in
which the polynomials and monomials live.

<DL>
<DT><STRONG><A NAME="item_monOrder">monOrder(ORDER) REQUIRED</A></STRONG><DD>
<P>
Fix a monomial ordering. Any existing polynomials will be converted to the
new ordering and any new polynomials will use this ordering. The available
orderings are:

<P>
<PRE>        tdeg            Total Degree (single variable case only) 
        lex             Lexicographic ordering
        grlex           Graded Lexicographic ordering.
        grevlex         Graded Reverse Lexicographic ordering.
</PRE>
<P>
<PRE>        For a detailed description of these orderings, refer to REFERENCES.
</PRE>
<P>
IMPORTANT: A monomial ordering MUST fixed before any polynomials are
created. This way, each polynomial knows how to construct itself given the
existing variables and variable ordering.

<p>

<DT><STRONG><A NAME="item_varOrder">varOrder(v1,...,vn) REQUIRED</A></STRONG><DD>
<P>
Fix a variable ordering.

<P>
<PRE>        For instance, suppose we wanted to have the relationship, x &gt; y &gt; z, we would declare this variable ordering via:
</PRE>
<P>
<PRE>        varOrder(x,y,z)
</PRE>
<P>
<PRE>        Consequently, when given z, x^3, y^2, for instance, the monomial would be constructed as:
</PRE>
<P>
<PRE>         x^3y^2z
</PRE>
<P>
IMPORTANT: If mult-variate polynomials are used, a variable order must be
fixed before any operations are performed. This way, each monomial knows
how to construct itself.

<p>

<DT><STRONG><A NAME="item_VAR">VAR = FUNCTION(...)</A></STRONG><DD>
<DT><STRONG>VAR = EXPRESSION</STRONG><DD>
<P>
These two statement forms provide the core of variable assignments.
Variable names are case sensitive and there can be no white space in the
name (not unlike most languages). For example:

<P>
<PRE>        v1 = x^3+3x-7;
</PRE>
<P>
<PRE>        and
        
        v2 = gcd(f,g);
        v3 = mult(v2,m);  
</PRE>
<p>

<DT><STRONG><A NAME="item_value">value(VAR)</A></STRONG><DD>
<P>
Return the value of VAR. This function is used primary to avoid confusion
in the following case:

<P>
<PRE>        monOrder(tdeg);
        f = x;
</PRE>
<p>

<DT><STRONG><A NAME="item_verbose">verbose</A></STRONG><DD>
<P>
By default, the polynomials display themselves as simply as possible. For
instance:

<P>
<PRE>        +1x^1y^3z^0 
</PRE>
<P>
<PRE>        is displayed as
</PRE>
<P>
<PRE>        xy
</PRE>
<P>
Toggling the verbose state will cause the polynomial to display itself in
its complete form. This format is useful if the user wants to see
completely the state of every component of the polynomial.

<P>
NOTE: the syntax for verbose is 

<P>
<PRE>        verbose()
</PRE>
<P>
Future plans include enhancements to this statement to create various
verbose configurations for differnt modes of debugging and displays.

<p>

<DT><STRONG><A NAME="item_state">state</A></STRONG><DD>
<P>
Display all the variables and orderings currently defined.

<p>

<DT><STRONG><A NAME="item_print">print(VARIABLE)</A></STRONG><DD>
<DT><STRONG><A NAME="item_print">print(STRING)</A></STRONG><DD>
<P>
Display the contents of the respective argument.

<p>

<DT><STRONG><A NAME="item_gbasis">gbasis(p1,p2,...,pn) [N]</A></STRONG><DD>
<P>
Computed the Groebner Basis of ideal generated by polynomials p1,p2,...,pn
using the simple Buchberger's algorithm. Since the simple algorithm is
being used, the basis is likely to be neither unique nor reduced unique for
the given polynomials.

<p>

<DT><STRONG><A NAME="item_spoly">spoly(p1,p2) [N]</A></STRONG><DD>
<P>
Determine the S-Polynomial for polynomials p1 and p2.

<p>

<DT><STRONG><A NAME="item_monLCM">monLCM(p1,p2) [N]</A></STRONG><DD>
<P>
Determine the monomial Least Common Multiple for polynomials p1 and p2. The
function uses the leading term of each p1 and p2 in its operation.

<p>

<DT><STRONG><A NAME="item_reduce">reduce(p)</A></STRONG><DD>
<P>
Attempt to reduce polynomial p and make it look like 'something' Maple
might give as a result. This is done by using the two strategies:

<P>
1) Reduce each coefficient to as close to 1 as possible.

<P>
2) If the leading term has a negative coefficient, then multiply each
coefficient by -1.

<p>

<DT><STRONG><A NAME="item_gcd">gcd(p1,p2) [1]</A></STRONG><DD>
<P>
Calculate the Greatest Common Divisor for polynomials p1 and p2.

<p>

<DT><STRONG><A NAME="item_quo">quo(p1,p2) [1]</A></STRONG><DD>
<P>
Determine the quotient of p1 / p2.

<p>

<DT><STRONG><A NAME="item_rem">rem(p1,p2) [N]</A></STRONG><DD>
<P>
Determine the remainder of p1 / p2.

<p>

<DT><STRONG><A NAME="item_divide">divide(p1,p2,...,pn) [N]</A></STRONG><DD>
<P>
Perform polynomial division: p1 / p2,...,pn. The result is a polynomial
list: [q1,...,qt,r], where t = n - 1. At this time there is no way to
access the elements of the list directly other than via printing the
assigned variable. For example,

<P>
f = <CODE>divide(p1,p2,p3,p4,p5);</CODE> <CODE>print(f);</CODE>

<P>
is the only way to see the contents of f.

<p>

<DT><STRONG><A NAME="item_normalf">normalf(p1,p2,...,pn) [N]</A></STRONG><DD>
<P>
Determine the Normal Form of p1,p2,...,pn. That is, do the polynomial
division and return the remainder. 

<p>

<DT><STRONG><A NAME="item_mult">mult(p1,p2) [N]</A></STRONG><DD>
<DT><STRONG><A NAME="item_subtract">subtract(p1,p2) [N]</A></STRONG><DD>
<DT><STRONG><A NAME="item_add">add(p1,p2) [N]</A></STRONG><DD>
<P>
Algebraic operations: *,-,+ respectively.

</DL>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<DL>
<DT><STRONG><A NAME="item_Example">Example 1</A></STRONG><DD>
<P>
An example illustrating single variable polynomials and calculating the
greatest common divisor of two polynomials.

<P>
<PRE>        monOrder(tdeg);
        varOrder(x);
        f = x^3-3x+2;
        g = x^6-1;
        gcd = gcd(f,g);
        print(f);
        print(g);
        print(gcd);
        reduce(gcd);
        print(gcd);
</PRE>
<DT><STRONG>Example 2</STRONG><DD>
<P>
This example illustrates the effect of the various monomial orderings on a
multi-variate polynomial.

<P>
<PRE>        monOrder(lex);
        varOrder(x,y,z);
        f = -xyz - x^2yz + x^3yz - xy^2 + xy^3z - xyz^2 + xyz^3;
        print(&quot;Monomial Ordering: LEX&quot;);
        print(f);
        monOrder(grlex);
        print(&quot;Monomial Ordering: GRLEX&quot;);
        print(f);
        monOrder(grevlex);
        print(&quot;Monomial Ordering: GREVLEX&quot;);
        print(f);
</PRE>
<DT><STRONG>Example 3</STRONG><DD>
<P>
Various simple algebraic operations on two single variable polynomials.

<P>
<PRE>        monOrder(grlex);
        varOrder(x,y,z);
        f = x^6-1;
        g = x^4-1;
        q = quo(f,g);
        r = rem(f,g);
        print(f);
        print(g);
        print(q);
        print(r);
        c = mult(q,g);
        s = add(c,r);
        print(s);
</PRE>
<DT><STRONG>Example 4</STRONG><DD>
<P>
The least common multiple and S-Polynomials are calcluated here from and f
and g. The operation monLCM uses the leading terms of f and g in its
operation.

<P>
<PRE>        monOrder(grlex);
        varOrder(x,y);
        f = x^3y^2-x^2y^3+x;
        g = 3x^4y+y^2;
        print(f);
        print(g);
        h = monLCM(f,g);
        print(h);
        s = spoly(f,g);
        print(s);
</PRE>
<DT><STRONG>Example 5</STRONG><DD>
<P>
Calculating the Groebner Basis is straight forward as illustrated here. The
two polynomials, s and h, are calculated as a validation the basis is
correct. That is, they have nothing to do with the operation of gbasis, but
are useful in illustrating the steps of calculating a Groebner Basis.

<P>
<PRE>        monOrder(grlex);
        varOrder(x,y);
        f = x^3-2xy; 
        g = x^2y-2y^2+x; 
        print(f);
        print(g);
        h = monLCM(f,g);
        print(h);
        s = spoly(f,g);
        print(s);
        gb = gbasis(f,g);
        print(gb);
</PRE>
</DL>
<P>
<HR>
<H1><A NAME="REFERENCES">REFERENCES</A></H1>
<P>
The algorithms implemented in this library were soley based on the work
presented in the book:

<P>
<PRE>        &quot;Ideals, Varieties, and Algorithms&quot;
        An Introduction to Computational Algebraic Geometry and Commutative Algebra
        Second Edition
        David Cox, John Little, Donal O'Shea
        Springer-Verlag 1997
        ISBN 0-387-94680-2
</PRE>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Brian Guarraci &lt;<AHREF="mailto:bguarrac@hotmail.com">bguarrac@hotmail.com</A>&gt;
</BODY>

</HTML>
